<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Model Viewer</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #model-container { width: 100%; height: 100vh; }
    </style>
</head>
<body>
<div id="model-container"></div>

<!-- Three.js Library -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<!-- OrbitControls -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<!-- STLLoader -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
<!-- URDFLoader -->
<script src="URDFLoader.js"></script>
<!-- numeric.js Library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>

<script>
    let scene, camera, renderer, controls;
    let robot; // Global variable for the robot model
    let enc1 = 332.524331;
    let enc2 = 332.996726;
    let enc3 = 62.8639697;
    let probe_state = 0;

    // Function to handle data received from Android
    function handleDataFromAndroid(data) {
        // Parse the data
        let dataParts = data.split(',');
        if (dataParts.length === 7) {
            let count = parseInt(dataParts[0]);
            let e4 = parseFloat(dataParts[1]);
            let e3 = parseFloat(dataParts[2]);
            let e2 = parseFloat(dataParts[3]);
            let e1 = parseFloat(dataParts[4]);
            let probe1 = parseInt(dataParts[5]);
            let probe2 = parseInt(dataParts[6]);

            // Update the robot model based on the angles
            updateScene(e1, e2, e3, e4, probe1);

        } else {
            console.error('Received data in unexpected format:', data);
        }
    }

    // Function to update the 3D scene with the new variables
    function updateScene(e1, e2, e3, e4, probe1) {
        if (robot) {
            // Set joint values (replace 'joint1', 'joint2', etc., with actual joint names)
            robot.setJointValue('Rev5', THREE.Math.degToRad(-e1+enc3));
            robot.setJointValue('Rev6', THREE.Math.degToRad(e2-enc2));
            robot.setJointValue('Rev7', THREE.Math.degToRad(-e3+enc1));
            robot.setJointValue('Rev8', THREE.Math.degToRad(-e4));

            // Update the robot's transformation
            robot.updateMatrixWorld(true);

            // Handle probe1 if needed
            if (probe1 === 0 && probe_state === 0) {
                // Implement any logic needed when probe1 is active
                probe_state = 1;
                console.log('Probe activated.');

            } else if (probe1 === 1 && probe_state === 1) {
                // Implement any logic needed when probe1 is inactive
                probe_state = 0;
                console.log('Probe deactivated.');

            }
        } else {
            console.warn('Robot model is not yet loaded.');
        }
    }

    // Initialize the 3D scene
    function init() {
        const container = document.getElementById('model-container');

        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xcccccc); // Gray background

        // Camera
        camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(0, 0.1, 0.6);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);

        // Lights
        const pointLight = new THREE.PointLight(0xffffff, 4, 100);
        pointLight.position.set(20, 20, 20);
        scene.add(pointLight);

        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
        hemiLight.position.set(0, 20, 0);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(-3, 10, -10);
        scene.add(dirLight);

        // Initialize OrbitControls
        try {
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Smooth controls
            controls.dampingFactor = 0.05;
            controls.enableZoom = true; // Allow zoom
            controls.enablePan = true; // Enable panning (translation)
            controls.rotateSpeed = 0.5; // Adjust rotation speed
            controls.minDistance = 0.1;
            controls.maxDistance = 2;
            controls.maxPolarAngle = Math.PI / 2;
            console.log('OrbitControls initialized successfully.');
        } catch (error) {
            console.error('Failed to initialize OrbitControls:', error);
        }

        // Load the URDF robot model
        loadURDFRobot();

        // Handle window resize
        window.addEventListener('resize', onWindowResize, false);

        // Start animation
        animate();
    }

    // Function to load the URDF robot model
    function loadURDFRobot() {
        const manager = new THREE.LoadingManager();
        const loader = new URDFLoader( manager );

        // Set the package path (where your meshes are located)
        loader.packages = {
            'V5_description': './V5_description',
        };

        // Load the URDF file
        loader.load('./V5_description/urdf/V5.urdf', function (urdfRobot) {
            robot = urdfRobot;
            scene.add(robot);

            // Adjust the robot's position, rotation, or scale
            robot.position.set(0, 0, 0);
            robot.rotation.x = - Math.PI / 2; // Adjust as necessary

            console.log('URDF robot loaded successfully.');
            console.log('Available joints:', robot.joints);
        }, undefined, function (error) {
            console.error('An error occurred while loading the URDF:', error);
        });
    }

    // Function to handle window resize
    function onWindowResize() {
        const container = document.getElementById('model-container');
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    }

    // Animation loop
    function animate() {
        requestAnimationFrame(animate);

        if (controls) {
            controls.update(); // Required if controls.enableDamping = true
        } else {
            console.warn('OrbitControls is undefined.');
        }

        renderer.render(scene, camera);
    }

    // Initialize the scene
    init();
</script>

</body>
</html>
