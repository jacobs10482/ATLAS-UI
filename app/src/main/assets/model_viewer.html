<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Model Viewer with TCP and Point Clouds</title>
    <style>
        /* [Your existing styles] */
        body { margin: 0; overflow: hidden; }
        #model-container { width: 100%; height: 100vh; }

        /* Connection Status Indicator */
        #connection-status {
            position: absolute;
            top: 10px; /* Position it 10px from the top */
            left: 10px; /* Position it 10px from the left */
            background-color: rgba(255, 255, 255, 0.8); /* Semi-transparent white background */
            padding: 8px 12px; /* Padding around the content */
            border-radius: 8px; /* Rounded corners */
            display: flex;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2); /* Subtle shadow for depth */
            z-index: 1000; /* Ensure it's above other elements */
        }

        /* Circle indicating connection status */
        .status-circle {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background-color: red; /* Default to red (Not Connected) */
            margin-right: 10px; /* Space between circle and text */
            transition: background-color 0.3s ease; /* Smooth color transition */
        }

        /* Text indicating connection status */
        .status-text {
            font-size: 14px;
            color: #333;
            font-weight: bold;
        }

        /* Reset Point Cloud Button Styling */
        #reset-button {
            position: absolute;
            top: 50px; /* Positioned below the connection status indicator */
            left: 10px;
            padding: 10px 20px;
            background-color: #ffffffaa;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s ease;
        }

        /* Register Button Styling */
        #register-button {
            position: absolute;
            top: 90px; /* Positioned below the Reset Point Cloud button */
            left: 10px;
            padding: 10px 20px;
            background-color: #ffffffaa;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s ease;
        }

        /* Reset Registration Button Styling */
        #reset-registration-button {
            position: absolute;
            top: 130px; /* Positioned below the Register button */
            left: 10px;
            padding: 10px 20px;
            background-color: #ffffffaa;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s ease;
        }

        /* Optional: Add a smooth transition for the connection status */
        #connection-status, #reset-button, #register-button, #reset-registration-button {
            transition: all 0.3s ease;
        }

        /* Progress Bar Container */
        #progress-container {
            position: absolute;
            bottom: 20px; /* 20px from the bottom */
            left: 50%;
            transform: translateX(-50%);
            width: 80%; /* 80% of the viewport width */
            max-width: 600px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px 20px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 1000; /* Ensure it's above other elements */
        }

        /* Progress Bar Background */
        #progress-bar {
            width: 100%;
            height: 20px;
            background-color: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 5px;
        }

        /* Progress Fill */
        #progress-fill {
            width: 0%;
            height: 100%;
            background-color: #76c7c0;
            transition: width 0.3s ease;
        }

        /* Progress Text */
        #progress-text {
            font-size: 14px;
            color: #333;
            font-weight: bold;
        }

    </style>
</head>
<body>
<div id="model-container"></div>

<!-- Connection Status Indicator -->
<div id="connection-status">
    <span class="status-circle" id="status-circle"></span>
    <span class="status-text" id="status-text">Not Connected</span>
</div>

<!-- Reset Point Cloud Button -->
<button id="reset-button">Reset Probe Point Cloud</button>

<!-- Register Button -->
<button id="register-button">Register</button>

<!-- Reset Registration Button -->
<button id="reset-registration-button">Reset Registration</button>

<!-- Progress Bar Container -->
<div id="progress-container">
    <div id="progress-bar">
        <div id="progress-fill"></div>
    </div>
    <div id="progress-text">Progress: 0%</div>
</div>


<!-- Three.js Library -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<!-- OrbitControls -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<!-- STLLoader -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
<!-- GLTFLoader -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<!-- URDFLoader -->
<script src="URDFLoader.js"></script>
<!-- Numeric.js Library Inclusion -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>

<script>
    // Global Variables
    let scene, camera, renderer, controls;
    let robot; // Global variable for the robot model
    let probe_state = 0;
    let probePointCloud, probeGeometry, probeMaterial; // Probe point cloud variables
    let phantomPointCloud, phantomGeometry, phantomMaterial; // Phantom point cloud variables
    let redPointCloud, redGeometry, redMaterial; // Points representing nose, nasion, left brow ridge

    const PROBE_MAX_POINTS = 2000; // Maximum number of points in the probe point cloud
    let probePointsCount = 0; // Current number of points added to probe point cloud

    let phantomModel; // Phantom model variable
    let ventriclesModel;

    // Constants for encoder offsets (as per your existing code)
    const enc1 = 332.524331;
    const enc2 = 332.996726;
    const enc3 = 62.8639697;

    // Connection Status Elements
    const statusCircle = document.getElementById('status-circle');
    const statusText = document.getElementById('status-text');

    // Variable to track the last time a frame was received
    let lastFrameTime = Date.now();

    // Arrays to store fixed and moving points
    let fixedPoints = []; // Fixed points (red points on the head)
    let movingPoints = []; // Moving points (collected from the probe)

    // Transformation Matrix
    let registrationMatrix = new THREE.Matrix4(); // To store the computed transformation

    /**
     * Initializes both the Probe and Phantom point clouds with preallocated buffers.
     */
    function initPointCloud() {
        // Initialize Probe Point Cloud (Blue)
        const probePositions = new Float32Array(PROBE_MAX_POINTS * 3);
        probeGeometry = new THREE.BufferGeometry();
        probeGeometry.setAttribute('position', new THREE.BufferAttribute(probePositions, 3));
        probeMaterial = new THREE.PointsMaterial({ color: 0x0000ff, size: 0.005 }); // Blue color
        probePointCloud = new THREE.Points(probeGeometry, probeMaterial);
        scene.add(probePointCloud);
        console.log('Probe point cloud initialized with preallocated buffer.');

        // Initialize Phantom Point Cloud (Green)
        const poissonMaxPoints = 20000; // Adjust based on your model's complexity
        const phantomPositions = new Float32Array(poissonMaxPoints * 3);
        phantomGeometry = new THREE.BufferGeometry();
        phantomGeometry.setAttribute('position', new THREE.BufferAttribute(phantomPositions, 3));
        phantomMaterial = new THREE.PointsMaterial({ color: 0x00ff00, size: 0.005 }); // Green color
        phantomPointCloud = new THREE.Points(phantomGeometry, phantomMaterial);
        scene.add(phantomPointCloud);
        console.log('Phantom point cloud initialized with preallocated buffer.');

        // Initialize Red Point Cloud (Red) with 3 points
        const redPositions = new Float32Array(3 * 3); // 3 points, each with x, y, z

        // Set initial positions approximately 0.1 units away from the origin
        // Adjust these values as per your coordinate system and model
        redPositions[0] = 0.036; redPositions[1] = 0.025; redPositions[2] = 0.11; // Tip of the nose
        redPositions[3] = 0.036; redPositions[4] = 0.055; redPositions[5] = 0.088; // Nasion
        redPositions[6] = 0.065; redPositions[7] = 0.07; redPositions[8] = 0.086; // Left brow ridge

        redGeometry = new THREE.BufferGeometry();
        redGeometry.setAttribute('position', new THREE.BufferAttribute(redPositions, 3));
        redMaterial = new THREE.PointsMaterial({ color: 0xff0000, size: 0.01 }); // Red color, slightly larger
        redPointCloud = new THREE.Points(redGeometry, redMaterial);
        scene.add(redPointCloud);
        console.log('Red point cloud initialized with 3 points.');

        // Populate fixedPoints with red points
        for (let i = 0; i < 3; i++) {
            const x = redPositions[i * 3];
            const y = redPositions[i * 3 + 1];
            const z = redPositions[i * 3 + 2];
            fixedPoints.push([x, y, z]); // Store as arrays for numeric.js
        }
        console.log('Fixed points (head landmarks) stored for registration.');
    }

    /**
     * Adds a point to the specified point cloud.
     * @param {THREE.Vector3} position - The world position to add to the point cloud.
     * @param {string} type - Type of the point cloud ('probe' or 'phantom').
     */
    function addPointToPointCloud(position, type) {
        if (type === 'probe') {
            if (probePointsCount >= PROBE_MAX_POINTS) {
                console.warn('Probe point cloud has reached its maximum capacity.');
                return;
            }
            // Set the x, y, z coordinates at the current index
            probeGeometry.attributes.position.setXYZ(probePointsCount, position.x, position.y, position.z);
            probePointsCount++;
            // Update the draw range
            probeGeometry.setDrawRange(0, probePointsCount);
            // Mark for update
            probeGeometry.attributes.position.needsUpdate = true;
            console.log(`Probe Point added at: (${position.x.toFixed(3)}, ${position.y.toFixed(3)}, ${position.z.toFixed(3)})`);
        } else if (type === 'phantom') {
            // Phantom point cloud does not get new points after initial sampling
            console.warn('Phantom point cloud is static and cannot be modified.');
        } else {
            console.error(`Unknown point cloud type: ${type}`);
        }
    }

    /**
     * Adds sampled points to the Phantom Point Cloud (Green).
     * This function is called only once after sampling.
     * @param {Array<Array<number>>} sampledPoints - Array of sampled points.
     */
    function addSampledPointsToPhantom(sampledPoints) {
        const scaleFactor = 0.001; // Scale down by a factor of 1000

        sampledPoints.forEach((point, index) => {
            // Apply scaling
            const scaledPoint = [
                point[0] * scaleFactor,
                point[1] * scaleFactor,
                point[2] * scaleFactor
            ];
            phantomGeometry.attributes.position.setXYZ(index, scaledPoint[0], scaledPoint[1], scaledPoint[2]);
        });

        // Update the draw range
        phantomGeometry.setDrawRange(0, sampledPoints.length);
        // Mark for update
        phantomGeometry.attributes.position.needsUpdate = true;
        console.log(`Phantom Point Cloud populated with ${sampledPoints.length} scaled points.`);
    }


    /**
     * Resets the Probe point cloud by clearing all points.
     */
    function resetProbePointCloud() {
        // Reset the point count
        probePointsCount = 0;

        // Update the draw range to exclude all points
        probeGeometry.setDrawRange(0, 0);

        // Mark the position attribute for update
        probeGeometry.attributes.position.needsUpdate = true;

        console.log('Probe point cloud reset.');

        resetRegistration();
    }

    /**
     * Function to handle data received from Android
     */
    window.handleDataFromAndroid = function(data) {
        // Update the last frame time to current time
        lastFrameTime = Date.now();

        // Parse the data
        let dataParts = data.split(',');
        if (dataParts.length === 7) {
            let count = parseInt(dataParts[0]);
            let e4 = parseFloat(dataParts[1]);
            let e3 = parseFloat(dataParts[2]);
            let e2 = parseFloat(dataParts[3]);
            let e1 = parseFloat(dataParts[4]);
            let probe1 = parseInt(dataParts[5]);
            let probe2 = parseInt(dataParts[6]);

            // Update the robot model based on the angles
            updateScene(e1, e2, e3, e4, probe1);
        } else {
            console.error('Received data in unexpected format:', data);
        }
    };

    /**
     * Function to update the 3D scene with the new variables
     */
    function updateScene(e1, e2, e3, e4, probe1) {
        if (robot) {
            // Set joint values (replace 'Rev5', 'Rev6', etc., with actual joint names)
            robot.setJointValue('Rev5', THREE.Math.degToRad(-e1 + enc3));
            robot.setJointValue('Rev6', THREE.Math.degToRad(e2 - enc2));
            robot.setJointValue('Rev7', THREE.Math.degToRad(-e3 + enc1));
            robot.setJointValue('Rev8', THREE.Math.degToRad(-e4));

            // Update the robot's transformation
            robot.updateMatrixWorld(true);

            // Measure the TCP's world position
            const tcpLink = robot.links['tcp_link'];
            if (tcpLink) {
                const tcpWorldPosition = new THREE.Vector3();
                tcpLink.getWorldPosition(tcpWorldPosition);
                // console.log('TCP World Position:', tcpWorldPosition);

                // Handle probe1 activation/deactivation
                if (probe1 === 0 && probe_state === 0) {
                    // Probe activated
                    probe_state = 1;
                    console.log('Probe activated.');
                    addPointToPointCloud(tcpWorldPosition, 'probe');

                    // Collect moving points for registration
                    collectMovingPoint(tcpWorldPosition);
                } else if (probe1 === 1 && probe_state === 1) {
                    // Probe deactivated
                    probe_state = 0;
                    console.log('Probe deactivated.');
                    // Optionally, implement actions on deactivation
                }
            } else {
                console.warn('TCP link not found.');
            }
        } else {
            // console.warn('Robot model is not yet loaded.');
        }
    }

    /**
     * Collects a moving point for registration.
     * @param {THREE.Vector3} position - The position to collect.
     */
    function collectMovingPoint(position) {
        if (movingPoints.length < 3) {
            movingPoints.push([position.x, position.y, position.z]); // Store as arrays for numeric.js
            console.log(`Collected Moving Point ${movingPoints.length}: (${position.x.toFixed(3)}, ${position.y.toFixed(3)}, ${position.z.toFixed(3)})`);
        } else {
            console.warn('Already collected 3 moving points for registration.');
        }
    }





    /**
     * Computes and logs the registration error between transformed moving points and fixed points.
     * @param {Array<Array<number>>} fixed - Fixed points.
     * @param {Array<Array<number>>} transformedMoving - Transformed moving points.
     */
    function computeRegistrationError(fixed, transformedMoving) {
        let totalError = 0;
        for (let i = 0; i < fixed.length; i++) {
            let error = Math.sqrt(
                Math.pow(fixed[i][0] - transformedMoving[i][0], 2) +
                Math.pow(fixed[i][1] - transformedMoving[i][1], 2) +
                Math.pow(fixed[i][2] - transformedMoving[i][2], 2)
            );
            console.log(`Point ${i}: Error = ${error}`);
            totalError += error;
        }
        let averageError = totalError / fixed.length;
        console.log(`Average Registration Error: ${averageError}`);
    }

    /**
     * Visualizes fixed points, moving points, and transformed moving points in the scene.
     * @param {THREE.Matrix4} registrationMatrix - The transformation matrix.
     */
    function visualizePoints(registrationMatrix) {
        // Remove existing point groups if they exist
        if (window.fixedPointsGroup) {
            scene.remove(window.fixedPointsGroup);
        }
        if (window.movingPointsGroup) {
            scene.remove(window.movingPointsGroup);
        }
        if (window.transformedMovingPointsGroup) {
            scene.remove(window.transformedMovingPointsGroup);
        }

        // Create group for fixed points
        let fixedPointsGeometry = new THREE.BufferGeometry();
        let fixedPositions = [];

        fixedPoints.forEach(point => {
            fixedPositions.push(point[0], point[1], point[2]);
        });

        fixedPointsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(fixedPositions, 3));
        let fixedMaterial = new THREE.PointsMaterial({ color: 0xff0000, size: 0.005 });
        window.fixedPointsGroup = new THREE.Points(fixedPointsGeometry, fixedMaterial);
        scene.add(window.fixedPointsGroup);

        // Create group for moving points
        let movingPointsGeometry = new THREE.BufferGeometry();
        let movingPositions = [];

        movingPoints.forEach(point => {
            movingPositions.push(point[0], point[1], point[2]);
        });

        movingPointsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(movingPositions, 3));
        let movingMaterial = new THREE.PointsMaterial({ color: 0x0000ff, size: 0.005 });
        window.movingPointsGroup = new THREE.Points(movingPointsGeometry, movingMaterial);
        scene.add(window.movingPointsGroup);

        // Create group for transformed moving points
        let transformedMovingPointsGeometry = new THREE.BufferGeometry();
        let transformedPositions = [];

        movingPoints.forEach(point => {
            // Create a Three.js Vector3 from the point
            let transformedVector = new THREE.Vector3(point[0], point[1], point[2]);
            // Apply the registration transformation
            transformedVector.applyMatrix4(registrationMatrix);
            // Store the transformed coordinates
            transformedPositions.push(transformedVector.x, transformedVector.y, transformedVector.z);
        });

        transformedMovingPointsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(transformedPositions, 3));
        let transformedMaterial = new THREE.PointsMaterial({ color: 0x00ff00, size: 0.005 });
        window.transformedMovingPointsGroup = new THREE.Points(transformedMovingPointsGeometry, transformedMaterial);
        scene.add(window.transformedMovingPointsGroup);

        console.log('Visualization of fixed, moving, and transformed moving points added to the scene.');

        // Compute transformed moving points for error analysis
        let transformedMoving = movingPoints.map(point => {
            let transformedVector = new THREE.Vector3(point[0], point[1], point[2]).applyMatrix4(registrationMatrix);
            return [transformedVector.x, transformedVector.y, transformedVector.z];
        });

        // Compute and log registration error
        computeRegistrationError(fixedPoints, transformedMoving);

        console.log('Visualization of fixed, moving, and transformed moving points added to the scene.');
    }


    /**
     * Computes the centroid of a set of points.
     * @param {Array<Array<number>>} points - Array of points (each point is an array [x, y, z]).
     * @returns {Array<number>} - Centroid as [x, y, z].
     */
    function computeCentroid(points) {
        let centroid = [0, 0, 0];
        points.forEach(point => {
            centroid[0] += point[0];
            centroid[1] += point[1];
            centroid[2] += point[2];
        });
        centroid = centroid.map(coord => coord / points.length);
        return centroid;
    }

    /**
     * Centers the points by subtracting the centroid.
     * @param {Array<Array<number>>} points - Array of points.
     * @param {Array<number>} centroid - Centroid as [x, y, z].
     * @returns {Array<Array<number>>} - Centered points.
     */
    function centerPoints(points, centroid) {
        return points.map(point => [
            point[0] - centroid[0],
            point[1] - centroid[1],
            point[2] - centroid[2]
        ]);
    }

    function determinant3x3(m) {
        return (
            m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1]) -
            m[0][1] * (m[1][0] * m[2][2] - m[1][2] * m[2][0]) +
            m[0][2] * (m[1][0] * m[2][1] - m[1][1] * m[2][0])
        );
    }

    function testRegistration() {
        // Define fixed points (e.g., identity)
        fixedPoints = [
            [1, 0, 0],
            [0, 1, 0],
            [0, 0, 1]
        ];

        // Define known rotation (90 degrees around Z-axis) and translation [1, 2, 3]
        let angle = Math.PI / 2; // 90 degrees
        let R_known = [
            [Math.cos(angle), -Math.sin(angle), 0],
            [Math.sin(angle), Math.cos(angle), 0],
            [0, 0, 1]
        ];
        let T_known = [1, 2, 3];

        // Compute moving points by applying R_known and T_known to fixed points
        movingPoints = fixedPoints.map(point => [
            R_known[0][0] * point[0] + R_known[0][1] * point[1] + R_known[0][2] * point[2],
            R_known[1][0] * point[0] + R_known[1][1] * point[1] + R_known[1][2] * point[2],
            R_known[2][0] * point[0] + R_known[2][1] * point[1] + R_known[2][2] * point[2]
        ]).map(point => [
            point[0] + T_known[0],
            point[1] + T_known[1],
            point[2] + T_known[2]
        ]);

        console.log('Fixed Points:', fixedPoints);
        console.log('Moving Points:', movingPoints);

        // Perform registration
        performRegistration();

        // Visualize the transformation
        visualizePoints(registrationMatrix);

        // Compute registration error
        let transformedMoving = movingPoints.map(point => {
            let transformedVector = new THREE.Vector3(point[0], point[1], point[2]).applyMatrix4(registrationMatrix);
            return [transformedVector.x, transformedVector.y, transformedVector.z];
        });
        computeRegistrationError(fixedPoints, transformedMoving);
    }


    /**
     * Performs registration using Arun's algorithm with numeric.js.
     */
    function performRegistration() {

        console.log('FixedPoints in performReg:', fixedPoints);
        console.log('MovingPoints in performReg:', movingPoints);
        if (fixedPoints.length !== 3 || movingPoints.length !== 3) {
            console.error('Registration requires exactly 3 fixed and 3 moving points.');
            alert('Please ensure you have collected exactly 3 points from the probe before registering.');
            return;
        }

        try {
            // Convert points to numeric.js matrices (3x3)
            let fixed = fixedPoints.map(point => [point[0], point[1], point[2]]);
            let moving = movingPoints.map(point => [point[0], point[1], point[2]]);

            console.log('Fixed Matrix:', fixed);
            console.log('Moving Matrix:', moving);

            // Calculate centroids
            let fixedCentroid = computeCentroid(fixed);
            let movingCentroid = computeCentroid(moving);

            console.log('Fixed Centroid:', fixedCentroid);
            console.log('Moving Centroid:', movingCentroid);

            // Center the points by subtracting centroids
            let q1 = centerPoints(fixed, fixedCentroid);
            let q2 = centerPoints(moving, movingCentroid);

            console.log('Q1 Matrix (Fixed - Centroid):', q1);
            console.log('Q2 Matrix (Moving - Centroid):', q2);

            // Compute covariance matrix H = q1 * q2^T
            let H = numeric.dot(numeric.transpose(q1), q2);
            console.log('Covariance Matrix H:', H);

            // Perform SVD on H
            let svdResult = numeric.svd(H);
            let U = svdResult.U;
            let S = svdResult.S;
            let V = svdResult.V;

            console.log('SVD Results - U Matrix:', U);
            console.log('SVD Results - S Vector:', S);
            console.log('SVD Results - V Matrix:', V);

            // Compute rotation matrix R = V * U^T
            let UT = numeric.transpose(U);
            let R = numeric.dot(V, UT);
            console.log('Initial Rotation Matrix R:', R);

            // Compute determinant of R
            let detR = numeric.det(R);
            console.log('Determinant of R:', detR);

            // Correct reflection if necessary
            if (detR < 0) {
                console.warn("Reflection detected. Correcting for proper rotation.");
                for (let i = 0; i < 3; i++) {
                    V[i][2] = -V[i][2]; // Flip the third column of V for proper rotation
                }
                R = numeric.dot(V, numeric.transpose(U));
                detR = numeric.det(R);
                console.log('Corrected Rotation Matrix R:', R);
                console.log('Determinant of corrected R:', detR);
            }

            // Compute translation vector T = movingCentroid - R * fixedCentroid
            let R_fixedCentroid = numeric.dot(R, fixedCentroid);
            let T = numeric.sub(movingCentroid, R_fixedCentroid);
            console.log('Translation Vector T:', T);

            // Create transformation matrix (4x4)
            let transformationMatrixNumeric = [
                [R[0][0], R[0][1], R[0][2], T[0]],
                [R[1][0], R[1][1], R[1][2], T[1]],
                [R[2][0], R[2][1], R[2][2], T[2]],
                [0, 0, 0, 1]
            ];
            console.log('Transformation Matrix:', transformationMatrixNumeric);

            // Flatten the matrix in column-major order for Three.js
            let flatMatrix = [
                transformationMatrixNumeric[0][0], transformationMatrixNumeric[1][0], transformationMatrixNumeric[2][0], transformationMatrixNumeric[3][0],
                transformationMatrixNumeric[0][1], transformationMatrixNumeric[1][1], transformationMatrixNumeric[2][1], transformationMatrixNumeric[3][1],
                transformationMatrixNumeric[0][2], transformationMatrixNumeric[1][2], transformationMatrixNumeric[2][2], transformationMatrixNumeric[3][2],
                transformationMatrixNumeric[0][3], transformationMatrixNumeric[1][3], transformationMatrixNumeric[2][3], transformationMatrixNumeric[3][3]
            ];

            // **Do not transpose the matrix again**
            registrationMatrix = new THREE.Matrix4();
            registrationMatrix.fromArray(flatMatrix);
            registrationMatrix = registrationMatrix.invert();
            console.log('Registration transformation matrix (Three.js Matrix4):', registrationMatrix.toArray());


            // Apply the transformation to the robot
            updateRobotOrigin(registrationMatrix);

            // Visualize the points
            visualizePoints(registrationMatrix);

            // Optionally, visualize the transformation
            // visualizeTransformation(registrationMatrix);

            // Clear moving points after registration
            // movingPoints = [];
        } catch (error) {
            console.error('An error occurred during registration:', error);
        }
        return registrationMatrix;
    }

    /**
     * Converts a vector to a diagonal matrix.
     * @param {Array<number>} S - Singular values vector.
     * @returns {Array<Array<number>>} - Diagonal matrix.
     */
    function vectorToDiagonalMatrix(S) {
        return [
            [S[0], 0, 0],
            [0, S[1], 0],
            [0, 0, S[2]]
        ];
    }




    /**
     * Updates the robot's origin by applying the transformation matrix.
     * @param {THREE.Matrix4} transformationMatrix - The transformation matrix to apply.
     */
    function updateRobotOrigin(transformationMatrix) {
        if (!robot) {
            console.error('Robot model is not loaded.');
            return;
        }

        // Apply the transformation to the robot's matrix
        robot.applyMatrix4(transformationMatrix);

        // Update the robot's matrix world
        robot.updateMatrixWorld(true);

        console.log('Robot origin updated based on registration.');
    }


    /**
     * Visualizes the transformation by adding a helper (optional).
     * @param {THREE.Matrix4} transformationMatrix - The transformation matrix to visualize.
     */
    function visualizeTransformation(transformationMatrix) {
        // Remove existing helpers if any
        scene.traverse(function(child) {
            if (child.isObject3D && child.name === 'RegistrationHelper') {
                scene.remove(child);
            }
        });

        // Create an axes helper to represent the transformation
        const registrationHelper = new THREE.AxesHelper(0.1);
        registrationHelper.name = 'RegistrationHelper';
        registrationHelper.applyMatrix4(transformationMatrix);
        scene.add(registrationHelper);

        console.log('Transformation visualization added to the scene.');
    }

    /**
     * Resets the registration process by clearing moving points and transformation.
     */
    function resetRegistration() {
        movingPoints = [];
        registrationMatrix.identity();

        // Remove transformation helper if any
        scene.traverse(function(child) {
            if (child.isObject3D && child.name === 'RegistrationHelper') {
                scene.remove(child);
            }
        });

        console.log('Registration reset. Ready to collect new points.');
        alert('Registration has been reset.');
    }

    /**
     * Simple Poisson Disk Sampling on a set of points.
     * Note: This is a naive implementation and may not be suitable for large datasets.
     * For better performance, consider using a dedicated library.
     * @param {Array<Array<number>>} points - Array of points to sample from.
     * @param {number} radius - Minimum distance between points.
     * @param {number} maxSamples - Maximum number of points to sample.
     * @returns {Array<Array<number>>} - Sampled points.
     */
    function poissonDiskSampling(points, radius, maxSamples) {
        // Shuffle the array
        let shuffled = points.slice();
        for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }

        let sampled = [];

        for (let i = 0; i < shuffled.length && sampled.length < maxSamples; i++) {
            let p = shuffled[i];
            let ok = true;
            for (let s = 0; s < sampled.length; s++) {
                let dx = p[0] - sampled[s][0];
                let dy = p[1] - sampled[s][1];
                let dz = p[2] - sampled[s][2];
                let distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                if (distance < radius) {
                    ok = false;
                    break;
                }
            }
            if (ok) {
                sampled.push(p.slice()); // Clone the point
            }
        }

        return sampled;
    }

    /**
     * Calculates an approximate radius for Poisson Disk Sampling based on desired number of points.
     * This is a heuristic and may need adjustment based on the model's size and point distribution.
     * @param {number} totalPoints - Total number of available points.
     * @param {number} desiredSamples - Desired number of samples.
     * @returns {number} - Calculated radius.
     */
    function calculatePoissonRadius(totalPoints, desiredSamples) {
        // Simple heuristic: average distance
        // This can be refined based on specific needs
        const boundingBox = new THREE.Box3().setFromObject(phantomModel);
        const size = boundingBox.getSize(new THREE.Vector3());
        const volume = size.x * size.y * size.z;
        const density = desiredSamples / volume;
        const radius = Math.pow(1 / density, 1 / 3) * 0.5; // Adjust multiplier as needed
        return radius;
    }

    /**
     * Samples points from the phantom model's surface using Poisson Disk Sampling.
     * @param {number} numPoints - Number of points to sample.
     */
    function samplePhantomPointCloud(numPoints) {
        if (!phantomModel) {
            console.warn('Phantom model is not loaded yet.');
            return;
        }

        // Ensure all transformations are applied
        phantomModel.updateMatrixWorld(true);

        // Extract geometries from the phantom model
        const geometries = getMeshGeometries(phantomModel);

        // Collect all vertices from all geometries
        let allVertices = [];
        geometries.forEach((geometry) => {
            const positionAttribute = geometry.attributes.position;
            for (let i = 0; i < positionAttribute.count; i++) {
                const vertex = new THREE.Vector3();
                vertex.fromBufferAttribute(positionAttribute, i);
                vertex.applyMatrix4(phantomModel.matrixWorld); // Convert to world coordinates
                allVertices.push([vertex.x, vertex.y, vertex.z]); // Store as arrays for numeric.js
            }
        });

        console.log(`Total vertices collected from phantom model: ${allVertices.length}`);

        // Perform Poisson Disk Sampling
        const radius = calculatePoissonRadius(allVertices.length, numPoints); // Calculate radius based on desired number of points
        const sampledPoints = poissonDiskSampling(allVertices, radius, numPoints);

        console.log(`Sampled ${sampledPoints.length} points using Poisson Disk Sampling.`);

        // Add sampled points to the Phantom Point Cloud
        addSampledPointsToPhantom(sampledPoints);
    }

    /**
     * Function to load the phantom.glb model
     */
    function loadPhantomModel() {
        const loader = new THREE.GLTFLoader();

        loader.load(
            'file:///android_asset/phantom.glb', // Replace with the correct path to your .glb file
            function (gltf) {
                phantomModel = gltf.scene;
                scene.add(phantomModel);

                // Apply initial transformations if needed
                phantomModel.position.set(0, 0, 0);
                phantomModel.scale.set(1, 1, 1);
                phantomModel.rotation.set(Math.PI / 2, 0, 0); // Adjust rotation as necessary

                console.log('Phantom model loaded successfully.');

                // Ensure transformations are applied
                phantomModel.updateMatrixWorld(true);

                // Traverse the model to modify material properties for transparency
                phantomModel.traverse(function (child) {
                    if (child.isMesh) {
                        // Clone the original material to avoid affecting other instances
                        const originalMaterial = child.material;
                        const transparentMaterial = originalMaterial.clone();

                        // Enable transparency and set opacity
                        transparentMaterial.transparent = true;
                        transparentMaterial.opacity = 0.6; // Adjust opacity (0 = fully transparent, 1 = fully opaque)

                        // Optional: Adjust additional material properties for better visuals
                        transparentMaterial.depthWrite = false; // Helps with rendering order of transparent objects
                        transparentMaterial.blending = THREE.NormalBlending; // Default blending mode

                        // Assign the new transparent material to the mesh
                        child.material = transparentMaterial;
                    }
                });

                // Sample point cloud from phantom model
                samplePhantomPointCloud(10000); // Sample 10000 points
            },
            undefined,
            function (error) {
                console.error('An error occurred while loading the phantom model:', error);
            }
        );
    }

    /**
     * Function to update the color of the ventriclesModel to red or green.
     * @param {string} color - The target color ("red" or "green").
     */
    function updateVentriclesColor(color) {
        // Ensure the ventriclesModel is loaded
        if (!ventriclesModel) {
            console.error('Ventricles model is not loaded. Please load the model before attempting to change its color.');
            return;
        }

        // Define a mapping from color names to hexadecimal color codes
        const colorMap = {
            'red': 0xff0000,    // Red color in hexadecimal
            'green': 0x00ff00   // Green color in hexadecimal
        };

        // Normalize the input color to lowercase to make the function case-insensitive
        const normalizedColor = color.toLowerCase();

        // Retrieve the hexadecimal color code from the colorMap
        const newColor = colorMap[normalizedColor];

        // Check if the provided color is supported
        if (!newColor) {
            console.error(`Unsupported color "${color}". Please use "red" or "green".`);
            return;
        }

        // Traverse the ventriclesModel to find all mesh components
        ventriclesModel.traverse(function(child) {
            if (child.isMesh && child.material && child.material.color) {
                // Update the material's color
                child.material.color.set(newColor);

                // Optionally, ensure that the material updates correctly
                child.material.needsUpdate = true;
            }
        });

        console.log(`Ventricles model color updated to ${normalizedColor}.`);
    }



    /**
     * Function to load the ventricles.glb model and set its color to red
     */
    function loadVentriclesModel() {
        const loader = new THREE.GLTFLoader();

        loader.load(
            'file:///android_asset/ventricles.glb', // Replace with the correct path to your ventricles.glb file
            function (gltf) {
                ventriclesModel = gltf.scene;
                scene.add(ventriclesModel);

                // Apply initial transformations if needed
                ventriclesModel.position.set(0, -0.070, 0); // Adjust position as necessary
                ventriclesModel.scale.set(1, 1, 1); // Adjust scale as necessary
                ventriclesModel.rotation.set(0, 0, 0); // Adjust rotation as necessary

                console.log('Ventricles model loaded successfully.');

                // Ensure transformations are applied
                ventriclesModel.updateMatrixWorld(true);

                // Traverse the model to modify material properties for transparency and color
                ventriclesModel.traverse(function (child) {
                    if (child.isMesh) {
                        // Clone the original material to avoid affecting other instances
                        const originalMaterial = child.material;
                        const transparentMaterial = originalMaterial.clone();

                        // Enable transparency and set opacity
                        transparentMaterial.transparent = true;
                        transparentMaterial.opacity = 1.0; // Adjust opacity (0 = fully transparent, 1 = fully opaque)

                        // Set the material color to red
                        // Ensure the material has a 'color' property (e.g., MeshStandardMaterial, MeshPhongMaterial)
                        if (transparentMaterial.color) {
                            transparentMaterial.color.set(0xff0000); // Red color in hexadecimal
                            // Alternatively, you can use:
                            // transparentMaterial.color.set('red');
                        } else {
                            console.warn(`Material on ${child.name} does not have a color property.`);
                        }

                        // Optional: Adjust additional material properties for better visuals
                        transparentMaterial.depthWrite = false; // Helps with rendering order of transparent objects
                        transparentMaterial.blending = THREE.NormalBlending; // Default blending mode

                        // Assign the new transparent material to the mesh
                        child.material = transparentMaterial;
                    }
                });
            },
            undefined,
            function (error) {
                console.error('An error occurred while loading the ventricles model:', error);
            }
        );
    }

    /**
     * Function to get all mesh geometries from an object.
     * @param {THREE.Object3D} object - The parent object to traverse.
     * @returns {Array<THREE.BufferGeometry>} - Array of BufferGeometries.
     */
    function getMeshGeometries(object) {
        let geometries = [];
        object.traverse(function (child) {
            if (child.isMesh) {
                // Ensure geometry is of type BufferGeometry
                let geometry = child.geometry;
                if (!(geometry instanceof THREE.BufferGeometry)) {
                    geometry = new THREE.BufferGeometry().fromGeometry(child.geometry);
                }
                geometries.push(geometry);
            }
        });
        return geometries;
    }

    /**
     * Initializes the 3D scene.
     */
    function init() {
        const container = document.getElementById('model-container');

        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xcccccc); // Light gray background

        // Camera
        camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(0, 0.1, 0.6);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);

        // Lights
        const pointLight = new THREE.PointLight(0xffffff, 4, 100);
        pointLight.position.set(20, 20, 20);
        scene.add(pointLight);

        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
        hemiLight.position.set(0, 20, 0);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(-3, 10, -10);
        scene.add(dirLight);

        // Initialize OrbitControls
        try {
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Smooth controls
            controls.dampingFactor = 0.05;
            controls.enableZoom = true; // Allow zoom
            controls.enablePan = true; // Enable panning (translation)
            controls.rotateSpeed = 0.5; // Adjust rotation speed
            controls.minDistance = 0.1;
            controls.maxDistance = 2;
            controls.maxPolarAngle = Math.PI / 2;
            console.log('OrbitControls initialized successfully.');
        } catch (error) {
            console.error('Failed to initialize OrbitControls:', error);
        }

        // Initialize point clouds
        initPointCloud();

        // Load the URDF robot model
        loadURDFRobot();

        // Load the phantom and ventricles models
        loadPhantomModel();
        loadVentriclesModel();

        // Handle window resize
        window.addEventListener('resize', onWindowResize, false);

        // Start animation
        animate();

        // Set up Reset Button functionality (only resets Probe Point Cloud)
        const resetButton = document.getElementById('reset-button');
        resetButton.addEventListener('click', function() {
            resetProbePointCloud();
        });

        // Set up Register Button functionality
        const registerButton = document.getElementById('register-button');
        registerButton.addEventListener('click', function() {
            registrationMatrix = performRegistration();
        });

        // Set up Reset Registration Button functionality
        const resetRegistrationButton = document.getElementById('reset-registration-button');
        resetRegistrationButton.addEventListener('click', function() {
            resetRegistration();
            resetProbePointCloud();
        });

        // Start the connection status checker
        startConnectionStatusChecker();
    }

    /**
     * Function to load the URDF robot model
     */
    function loadURDFRobot() {
        const manager = new THREE.LoadingManager();
        const loader = new URDFLoader(manager);

        // Set the package path (where your meshes are located)
        loader.packages = {
            'V5_description': './V5_description',
        };

        // Load the URDF file
        loader.load('./V5_description/urdf/V5.urdf', function (urdfRobot) {
            robot = urdfRobot;
            scene.add(robot);

            // Adjust the robot's position, rotation, or scale
            robot.position.set(0, 0, 0);
            robot.rotation.x = 0; // Adjust as necessary

            console.log('URDF robot loaded successfully.');
            console.log('Available joints:', Object.keys(robot.joints));
            console.log('Available links:', Object.keys(robot.links));

            // Access the TCP link
            const tcpLink = robot.links['tcp_link'];
            if (tcpLink) {
                console.log('TCP link found:', tcpLink);
            } else {
                console.warn('TCP link not found.');
            }

        }, undefined, function (error) {
            console.error('An error occurred while loading the URDF:', error);
        });
    }

    /**
     * Function to handle window resize
     */
    function onWindowResize() {
        const container = document.getElementById('model-container');
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    }

    /**
     * Animation loop
     */
    function animate() {
        requestAnimationFrame(animate);

        if (controls) {
            controls.update(); // Required if controls.enableDamping = true
        } else {
            console.warn('OrbitControls is undefined.');
        }

        renderer.render(scene, camera);
    }

    /**
     * Function to check and update connection status
     */
    function startConnectionStatusChecker() {
        setInterval(() => {
            const currentTime = Date.now();
            const timeSinceLastFrame = currentTime - lastFrameTime;

            if (timeSinceLastFrame <= 1000) { // 1 second threshold
                // Connected
                updateConnectionStatus(true);
            } else {
                // Not Connected
                updateConnectionStatus(false);
            }
        }, 500); // Check every 500ms
    }

    /**
     * Updates the connection status indicator.
     * @param {boolean} isConnected - True if connected, false otherwise.
     */
    function updateConnectionStatus(isConnected) {
        if (isConnected) {
            statusCircle.style.backgroundColor = 'green';
            statusText.textContent = 'Connected';
        } else {
            statusCircle.style.backgroundColor = 'red';
            statusText.textContent = 'Not Connected';
        }
    }

    // Initialize the 3D scene when the page loads
    window.onload = init;
</script>

</body>
</html>
